# Проект StringCompleter
## Задание
Поиск по словарю
Написать UI приложение для поиска слов в англоязычном словаре.


## Внешний вид = 2 UI элемента: 
однострочное поле для ввода текста и многострочное поле для вывода текста. 

У меня получилось сделать вот такой интерфейс:
![image](https://user-images.githubusercontent.com/7702419/114311066-e97ed300-9af5-11eb-9cef-81941749b89e.png)

## Функциональность
При вводе текста в поле для ввода, в поле для вывода должны отображаться результаты поиска в словаре. У меня получилось сделать и для поиска введенной строки как подстроки так и подпоследовательности. Я оставил в последней версии именно поиск строки в качестве подпослежовательности, так как посчитал это более содержательным:

```
/**
 * Проверка на принадлежность строки sub строке text в качестве подпоследовательности
 *
 * Будем это делать следующим образом:
 *
 * Будем искать именно первое вхождение в качестве подпоследовательности
 *
 * Для этого будем всегда искать самое первое вхождение буквы после
 * самого раннего вхождения префикса идущего до нее проверяемого subsequence
 *
 * Соответственно если мы для всех элементов предполагаемой подпоследовательности нашли их ранние отображения, то
 * это действительно подпоследовательность.
 * Если же мы не смогли найти, то она не является подпоследовательностью. Докажем это, пойдя от противного:
 *
 * пусть это подпоследовательность а мы сказали что нет, тогда выберем в text последовательные индексы {i_0, i_1, ...}
 * Тогда subsequence[0] = text[i_0], subsequence[1] = text[i_1], ... Тогда для каждого из элементов в subsequence
 * можно выбрать индекс меньше соответствующего, то есть если обозначить первое вхождение элемента k после
 * первого вхождения всех предыдущих за inning[k], то inning[k] <= i_k. Значит inning[i_n] < i_n, где n = subsequence.len
 * Асимптотика такого решения равна O(n), где n - длина строки в которой ищется подпоследовательность.
 * Кстати говоря асимптотика нахождения подстроки в строке может также равняться O(n), если использовать Z-функцию, но 
 * так как это опциональное задание состояло именно в этом, поэтому писать Z-функцию я не стал
 */
private fun isSubsequence(subsequence: String, text: String): Boolean {
    var indexSub = 0 // последний индекс в subsequence, для которого нет отображения на обработанном префиксе text

    if (subsequence.isBlank()) return false // Нам не нужны пустые слова
    if (subsequence.length > text.length) return false

    for (char in text) {
        if (char == subsequence[indexSub]) indexSub++

        if (indexSub == subsequence.length) return true // если последний индекс для которого
        // нет отображения большего его размера, значит мы это действительно подпоследовательность
    }
    return false
}


```

## Особые требования

### 1 Приложение должно запускаться как можно быстро.

Моя реализация данной задачи запускает приложение со скоростью загрузки интерфейса за счет того что я выполняю загрузку словаря в отдельном потоке, не мешая визуальной составляющей.

### 2 При печати в поле ввода, не должно быть "повисаний", "задержек", любых артефактов, мешающих печати.

Не смог отловить какие-либо задержки, мешающие печати. Этот момент я обходил с помощью запуска отдельного потока в котором получал авто-дополнения из flow потока.

### 3 Результаты поиска должны отображаться в поле вывода как можно раньше. Не обязательно сразу отображать все возможные совпадения, но пользователь должен понимать, что видит не все результаты поиска.

Здесь я заметил, что на экране помещается максимум примерно 30-40 слов, а то и меньше, поэтому если каждый раз в том самом flow-потоке из предыдущего пункта забирать только количество слов, примерно равное 100, то это будет происходить достаточно быстро. При этом при каждой такой находке сотни авто-дополнений их можно передать в состояние, чтобы отрисовать на главном экране. Оставалась единственная проблема - нужно было останавливать обработку предыдущего введенного слова для старта новой. Ровно это я и сделал, сохранив поток в переменную и останавливая его при изменении введенной пользователем строки

## Опциональные задания
### К поиску по подстроке добавить поиск по последовательным символам.
Пример: при слове cat, совпадением будет считаться climate

Алгоритм этого я уже описал в разделе ** Функциональность  **

### Не хранить словарь в памяти процесса

У меня есть вариант решения, но я не успел её реализовать по-хорошему, но идея в следующем:

Если хранить словарь в памяти процесса нельзя, то можно хранить ее в локальном файле. Таким образом повторная загрузка файла по URL не будет требоваться.

Однако тогда мы сильно увеличим время загрузки словаря в память и не сможем им пользоваться пока он полностью не запишется в память, если на файл может быть открыт либо только на чтение, либо только на вывод.

Однако даже если мы создадим эту базу данных, то время, которое нам понадобится для отображения, содержащих в себе пользовательский ввод, возрастет, так как операция получения данных из базы данных дороже операции взятия данных из памяти процесса.

## Найденные баги с которыми я не понял, что делать

1) Если ввести в текстовое поле много пробелов и несколько символов, а потом их все удалить, то вылезает исключение связанное с библиотекой пользовательского интерфейса (Jetpack compose)

2) Если передать в поле какую-нибудь сложную ссылку или вставить что-то мудреное, то возникает ошибка связанная с юникодом.

## Дополнительный функционал

Добавлены тесты, которые можно запустить либо из файла с тестами, либо из IDE.
